% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/cv_abm.R
\name{cv_abm}
\alias{cv_abm}
\title{Estimate and Test an ABM}
\usage{
cv_abm(data, features, Formula, k, agg_patterns, abm_simulate, abm_vars, iters,
  tseries_len, tp = rep(tseries_len, nrow(agg_patterns)),
  package = c("caretglm", "caretglmnet", "glm", "caretnnet", "caretdnn"),
  sampling = FALSE, sampling_size = 1000, outcome_var_name = "action",
  STAT = c("mean", "median"), saving = FALSE, filename = NULL,
  abm_optim = c("GA", "DE"), validate = c("lgocv", "cv"),
  folds = ifelse(validate == "lgocv", max(data$group), 10),
  drop_nzv = FALSE, verbose = TRUE, predict_test_par = FALSE,
  optimize_abm_par = FALSE, parallel_training = FALSE)
}
\arguments{
\item{data}{\code{data.frame} with each row (obervational unit) being an
individual decision. With a column named "group" specifying which group of
\code{agg_patterns} each obseravtion is in, and a column named "period"
specifying at what time period each behavior was taken.}

\item{features}{\code{list} of the variables (columns in \code{data}) to be
used in the prediction \code{Formula}. As many elements in the \code{list}
as we want discrete models for different times. Each element of the
\code{list} is a \code{character vector}, with each element of the
\code{character vector} being a feature to use for training an
individual-level model.}

\item{Formula}{\code{list} where each element is a length one character vector
that specifies a formula, e.g. \code{"y ~ x"}. The character vector makes
sense in the context of the \code{features} and \code{data}. There are as
many elements in the list as there are discrete models for different times.}

\item{k}{numeric vector length one specifying the time periods that should
estimate model, and thus also specifying the number of models to estimate.}

\item{agg_patterns}{data.frame with rows (observational unit) being the group
and columns: (a.) those aggregate level variables needed for the prediction
with the specified \code{formula} (with same names as the variables in the
formula); (b.) a column named "action" with the proportion of the relevant
outcome action taken in that group; (c.) columns named
\code{paste(seq(tseries_len))} with the mean/median levels (\code{STAT}) of
the action for each time period.}

\item{abm_simulate}{function with these arguments: \code{model, features,
parameters, tuning_parameters, iterations, time_len, STAT = c("mean",
"median")}. Where \code{model} is the output of \code{\link{training}}.
Output of the function is a list with three named elements: \code{dynamics,
action_avg, simdata}. Where \code{dynamics} is a numeric vector length
\code{tseries_len}, \code{action_avg} is a numeric vector length one, and
\code{simdata} is a \code{data.frame} with the numeric results of the
simulation.}

\item{abm_vars}{a list with either (1.) a numeric vector named "lower" AND a
numeric vector named "upper" each the length of the number of tuning_params
of ABM (the names of the elements of these vecs should be the names of the
variables and they should be in the same order that the \code{abm_simulate}
function uses them); or (2.) a numeric vector named "value" the length of
the number of tuning_params of the ABM (variables should be in the same
order that the \code{abm_simulate} function uses them). Either provide lower
and upper elements of the list or provide a value element of the list.}

\item{iters}{numeric vector length one specifying number of iterations to
simulate ABM for.}

\item{tseries_len}{numeric vector length one specifying maximum number of time
periods to use for model training and testing. If some groups have less than
the maximum then you need to provide a vector to the \code{tp} argument.}

\item{tp}{optional numeric vector length number of rows of \code{agg_patterns}
specifying how long the time series for each group should be. Default is
\code{rep(tseries_len, nrow(agg_patterns))}.}

\item{package}{optional character vector length one, default is
\code{"caretglm", "caretglmnet", "glm", "caretnnet", "caretdnn"}.}

\item{sampling}{optional logical vector length one, default is \code{FALSE}.
If \code{sampling == TRUE}, we sample equal numbers of observations from
each 'group' to reduce potential problems with the final estimated model
being too affected by groups with more observations.}

\item{sampling_size}{optional numeric vector length one specifying how many
observations from each group that \code{\link{training}} should sample to
train the model, default is 1000. Only applicable when \code{sampling}
argument is set to \code{TRUE}.}

\item{outcome_var_name}{optional character vector length one, default is
\code{"action"}. \code{\link{training}} uses it to sample to train the model
with a balanced sampling based on \code{outcome_var_name}. Only applicable
when \code{sampling} argument is set to \code{TRUE}.}

\item{STAT}{optional character vector length one, default is \code{c("mean",
"median")}.}

\item{saving}{optional logical vector length one, default is \code{FALSE}.}

\item{filename}{optional character vector length one, default is \code{NULL}.}

\item{abm_optim}{optional character vector length one, default is
\code{c("GA", "DE")}.}

\item{validate}{optional character vector length one, default is
\code{c("lgocv", "cv")}.}

\item{folds}{optional numeric vector length one, default is
\code{ifelse(validate == "lgocv", max(data$group), 10)}.}

\item{drop_nzv}{optional logical vector length one, default is \code{FALSE}.}

\item{verbose}{optional logical vector length one, default is \code{TRUE}.}

\item{predict_test_par}{optional logical vector length one, default is
\code{FALSE}. If you are getting any errors with this function, make sure
you set args like this to FALSE because debugging in parallel is much
harder.}

\item{optimize_abm_par}{optional logical vector length one, default is
\code{FALSE}. This is passed to the optimization algorithm.}

\item{parallel_training}{optional logical vector length one, default is
 \code{FALSE}. This is passed to \code{\link{training}}.}
}
\value{
Returns an S4 object of class \linkS4class{cv_abm}. With slots for
 \code{call = "language", predicted_patterns = "list", timing = "numeric",
 and diagnostics = "character"}.
}
\description{
\code{cv_abm} uses cross-validation to test an ABM's predictive power.
}
\details{
The function returns an S4 object. See \linkS4class{cv_abm} for the details of
the \code{slots} (objects) that this type of object will have.
}
\examples{
# Create data:
cdata <- data.frame(period = rep(seq(10), 1000),
                   action = rep(0:1, 5000),
                 my.decision1 = sample(1:0, 10000, TRUE),
                 other.decision1 = sample(1:0, 10000, TRUE),
                 group = c(rep(1, 5000), rep(2, 5000)))
time_len <- 2
agg_patterns <- data.frame(group = c(1,2),
                        action = c( mean(as.numeric(cdata[cdata$group==1, "action"])),
                                    mean(as.numeric(cdata[cdata$group==2, "action"]))),
                        c(eat::period_vec_create(cdata[cdata$group==1, ], time_len)[1],
                          eat::period_vec_create(cdata[cdata$group==2, ], time_len)[1]),
                        c(eat::period_vec_create(cdata[cdata$group==1, ], time_len)[2],
                          eat::period_vec_create(cdata[cdata$group==2, ], time_len)[2]))
names(agg_patterns)[3:4] <- c("1", "2")

# Create ABM:
simulate_abm <- function(model, features, parameters, time_len,
                        tuning_parameters,
                      iterations = 1250, STAT = "mean"){
matrixOut <- data.frame(period = rep(1:10, 1000),
                       action = rep(0:1, 5000),
                       my.decision1 = sample(1:0, 10000, TRUE),
                       other.decision1 = sample(1:0, 10000, TRUE))
action_avg <- mean(matrixOut$action, na.rm=TRUE)
dynamics <- period_vec_create(matrixOut, time_len)
list(dynamics = dynamics, action_avg = action_avg, simdata = matrixOut)
}
# Create features and formula lists:
k <- 1
features <- as.list(rep(NA, k)) # create list to fill
features[[1]] <- c("my.decision1", "other.decision1")
Formula <- as.list(rep(NA, k)) # create list to fill
Formula[[1]] <- "action ~ my.decision1 + other.decision1"
# Call cv_abm():
res <- cv_abm(cdata, features, Formula, k, agg_patterns,
             outcome_var_name = "action",
             abm_simulate = simulate_abm,
             abm_vars = list(values = c(0.3, 0.5)),
             iters = 1000,
             tseries_len = time_len,
             tp = c(1, 2),
             package = "caretglm",
             STAT = "mean",
             saving = FALSE, filename = NULL,
             validate = "lgocv",
             drop_nzv = FALSE,
             predict_test_par = FALSE)

summary(res)
#plot(res)
#performance(res, "cor_pval")
}


% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/cv_abm.R
\name{cv_abm}
\alias{cv_abm}
\title{Estimate and Test an ABM}
\usage{
cv_abm(data, features, Formula, k, agg_patterns, abm_simulate, abm_vars, iters,
  tseries_len, tp = rep(tseries_len, nrow(agg_patterns)),
  package = c("caretglm", "caretglmnet", "glm", "caretnnet", "caretdnn"),
  sampling = FALSE, STAT = c("mean", "median"), saving = FALSE,
  filename = NULL, abm_optim = c("GA", "DE"), validate = c("lgocv", "cv"),
  folds = ifelse(validate == "lgocv", max(data$group), 10), repeat_cv = 1,
  drop_nzv = TRUE, verbose = TRUE, predict_test_par = FALSE,
  parallel_training = FALSE)
}
\arguments{
\item{data}{data.frame with each row (obervational unit) being an individual decision. With
a column called "group" specifying which group of \code{agg_patterns} each obseravtion is in.}

\item{features}{list of the variables (columns in \code{data}) to be used in the prediction
\code{Formula}. As many elements in the list (character vectors) as we want discrete models for
different times.}

\item{Formula}{list of character vectors that specify a formula, e.g. \code{"y ~ x"}, that makes
sense in the context of the \code{features} and \code{data}. As many elements in the list
as discrete models for different times.}

\item{k}{numeric vector length one specifying the number of models for different times.}

\item{agg_patterns}{data.frame with rows (observational unit) being the group
and columns: (a.) those aggregate level variables needed for the prediction with the
specified \code{formula} (with same names as the variables in the formula); (b.) a column
named "action" with the proportion of the relevant action taken in that group;
 (c.) columns named \code{paste(seq(tseries_len))} with the mean/median levels (\code{STAT})
 of the action for each time period.}

\item{abm_simulate}{function with these arguments: model, features, parameters, tuning_parameters,
iterations, time_len, STAT = c("mean", "median"). Output of thefunction is a list with three named
elements: \code{dynamics, action_avg, simdata}. Where
\code{dynamics} is a vector length \code{tseries_len}, \code{action_avg} is a vector
length one, and \code{simdata} is a \code{data.frame}.}

\item{abm_vars}{a list with either (1.) a numeric vector named "lower" and a numeric vector
named "upper" each the length of the number of tuning_params of ABM (the names of the elements
 of these vecs should be the names of the variables and they should be in the same order that
 the \code{abm_simulate} function uses them); or (2.) a numeric vector named "value" the
 length of the number of tuning_params of ABM (variables should be in the same order that
 the \code{abm_simulate} function uses them).}

\item{iters}{numeric vector length one specifying number of iterations to simulate ABM for.}

\item{tseries_len}{numeric vector length one specifying maximum number of time periods
to use for model training and testing. If some groups have less than the maximum then
you need to provide a vector to the \code{tp} argument.}

\item{tp}{optional numeric vector length number of rows of \code{agg_patterns} specifying how
long the time series for each group should be. Default is
\code{rep(tseries_len, nrow(agg_patterns))}.}

\item{package}{optional character vector length one, default is
\code{"caretglm", "caretglmnet", "glm", "caretnnet", "caretdnn"}.}

\item{sampling}{optional logical vector length one, default is \code{FALSE}.}

\item{STAT}{optional character vector length one, default is \code{c("mean", "median")}.}

\item{saving}{optional logical vector length one, default is \code{FALSE}.}

\item{filename}{optional character vector length one, default is \code{NULL}.}

\item{abm_optim}{optional character vector length one, default is \code{c("GA", "DE")}.}

\item{validate}{optional character vector length one, default is \code{c("lgocv", "cv")}.}

\item{folds}{optional numeric vector length one, default is
\code{ifelse(validate == "lgocv", max(data$group), 10)}.}

\item{repeat_cv}{optional numeric vector length one, default is \code{1}.}

\item{drop_nzv}{optional logical vector length one, default is \code{TRUE}.}

\item{verbose}{optional logical vector length one, default is \code{TRUE}.}

\item{predict_test_par}{optional logical vector length one, default is \code{FALSE}.}

\item{parallel_training}{optional logical vector length one, default is \code{FALSE}.
This is passed to \code{\link{training}}.}
}
\value{
Returns an S4 object of class \linkS4class{cv_abm}. With slots for
\code{call = "language", predicted_patterns = "list", timing = "numeric", and
diagnostics = "character"}.
}
\description{
\code{cv_abm} uses cross-validation to test an ABM's predictive power.
}
\details{
The function returns an S4 object.
See \linkS4class{cv_abm} for the details of the \code{slots}
(objects) that this type of object will have.
}
\examples{
# Helper fuction:
period_vec_create <- function(datasubset, periods,
                             STAT = "mean"){
 period_vec <- rep(NA, length(periods))
 for (i in seq(periods)){
   if (nrow(datasubset[datasubset$period==i, ]) > 0){
     period_vec[i] <- do.call(STAT,
                              list(x = as.numeric(datasubset[datasubset$period==i, which(names(datasubset) \%in\% "outcome")]),
                                   na.rm = TRUE))
     # period_vec[i] <- mean(datasubset[datasubset$period==i, which(names(datasubset) \%in\% "decision_p")], na.rm = TRUE)
   } else{
     period_vec[i] <- NA
   }
 }
 stopifnot(length(period_vec)==periods)
 period_vec
}
# Create data:
cdata <- data.frame(period = rep(seq(10), 1000),
                   outcome = rep(0:1, 5000),
                   my.decision1 = sample(1:0, 10000, TRUE),
                   other.decision1 = sample(1:0, 10000, TRUE),
                   group = c(rep(1, 5000), rep(2, 5000)))
time_len <- 2
agg_patterns <- data.frame(group = c(1,2),
                          action = c( mean(as.numeric(cdata[cdata$group==1, "outcome"])),
                                      mean(as.numeric(cdata[cdata$group==2, "outcome"]))),
                          c(period_vec_create(cdata[cdata$group==1, ], time_len)[1],
                            period_vec_create(cdata[cdata$group==2, ], time_len)[1]),
                          c(period_vec_create(cdata[cdata$group==1, ], time_len)[2],
                            period_vec_create(cdata[cdata$group==2, ], time_len)[2]))
names(agg_patterns)[3:4] <- c("1", "2")

# Create ABM:
simulate_abm <- function(model, features, parameters, time_len, noise,
                        threshold = 0.5, iterations = 1250, STAT = "mean"){
 matrixOut <- data.frame(period = rep(1:10, 1000),
                         outcome = rep(0:1, 5000),
                         my.decision1 = sample(1:0, 10000, TRUE),
                         other.decision1 = sample(1:0, 10000, TRUE))
 action_avg <- mean(matrixOut$outcome, na.rm=TRUE)
 dynamics <- period_vec_create(matrixOut, time_len)
 list(dynamics = dynamics, action_avg = action_avg, simdata = matrixOut)
}
# Create features and formula lists:
k <- 1
features <- as.list(rep(NA, k)) # create list to fill
features[[1]] <- c("my.decision1", "other.decision1")
Formula <- as.list(rep(NA, k)) # create list to fill
Formula[[1]] <- "outcome ~ my.decision1 + other.decision1"
# Call cv_abm():
res <- cv_abm(cdata, features, Formula, k, agg_patterns,
             abm_simulate = simulate_abm,
             tseries_len = time_len,
             package = "caretglm",
             sampling = FALSE,
             STAT = "mean",
             saving = FALSE, filename = NULL,
             abm_vars  = list(noise = 0.25, threshold = 0.50),
             validate = c("lgocv"),
             drop_nzv = FALSE,
             verbose = TRUE,
             predict_test_par = FALSE)
cat(res@diagnostics)
}

